<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Scratchpad</title>
    <link rel="manifest" href="/manifest.json">
    <link rel="icon" href="/icons/icon-192x192.png" type="image/png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        /* Custom styles for the modes */
        /* Using CSS variables for easier color management */
        :root {
            --light-bg: #fafafa; /* A lighter shade of grey for the body background */
            --light-text: #000000; /* Black */
            --dark-bg: #000000; /* Black for the body background */
            --dark-text: #80deea; /* Material 3 Light Teal for dark mode text */
            --light-button-bg: #4db6ac; /* Material 3 Teal 300 for light mode buttons (darker teal) */
            --light-button-hover-bg: #26a69a; /* Material 3 Teal 400 for hover state (even darker) */
            --dark-button-bg: #1a1a1a; /* Darker grey for dark mode buttons */
            --dark-button-hover-bg: #2a2a2a; /* Hover state for dark mode buttons */
            --accent-color-light: #4dd0e1; /* Material 3 Cyan 400 for light mode toggle */
            --accent-color-dark: #80deea; /* Material 3 Light Teal for dark mode toggle */
            --focus-ring-color-light: rgba(77, 208, 225, 0.5); /* Semi-transparent Cyan 400 for light mode focus */
            --focus-ring-color-dark: rgba(128, 222, 234, 0.5); /* Semi-transparent Light Teal for dark mode focus */
            --floating-bg-light: rgba(224, 247, 250, 0.9); /* Very light teal with transparency for light mode floating container */
            --floating-bg-dark: rgba(25, 35, 40, 0.9); /* A dark blue-grey with a hint of teal for dark mode floating container */
            --textarea-bg-light: #e0f2f7; /* Very pale teal for light mode textarea background */
        }

        .light-mode {
            background-color: var(--light-bg); /* Body background in light mode */
            color: var(--light-text);
        }

        .dark-mode {
            background-color: var(--dark-bg); /* Body background in dark mode */
            color: var(--dark-text);
        }

        body {
            margin: 0; /* Remove default body margin */
            display: flex; /* Use flexbox for body to manage layout */
            flex-direction: column; /* Stack children vertically */
            min-height: 100vh; /* Ensure body takes at least full viewport height */
            transition: background-color 0.3s ease, color 0.3s ease; /* Smooth transition for mode change */
            padding: 0; /* Remove body padding */
        }

        .full-height-textarea {
            flex-grow: 1; /* Allows the textarea to take up available space within the body */
            resize: none; /* Disable manual resizing */
            outline: none; /* Remove default outline */
            padding: 1.5rem; /* Add padding inside the textarea */
            /* padding-bottom will be set by JavaScript dynamically */
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; /* Monospace font for scratchpad feel */
            color: inherit; /* Text color inherits from body */
            width: 100%; /* Ensure textarea takes full width */
            box-sizing: border-box; /* Include padding in the element's total width and height */
            font-size: 1.35rem; /* Slightly increased font size */
            line-height: 1.6; /* Increased line height for better readability */
            transition: background-color 0.3s ease, padding-bottom 0.3s ease; /* Smooth transition for background and padding */
            overflow-y: auto; /* Enable scrolling within the textarea */
        }

        /* Set the textarea background specifically based on mode */
        .light-mode .full-height-textarea {
             background-color: var(--textarea-bg-light); /* Very pale teal background in light mode */
        }

        .dark-mode .full-height-textarea {
             background-color: var(--dark-bg); /* Black background in dark mode */
        }


        /* Style for buttons (now icon buttons) */
        .app-button {
            display: flex; /* Use flexbox to center icon */
            justify-content: center;
            align-items: center;
            width: 3.5rem; /* Slightly larger buttons */
            height: 3.5rem; /* Slightly larger buttons */
            border-radius: 0.75rem; /* More rounded corners */
            font-weight: bold;
            transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out, box-shadow 0.2s ease-in-out, transform 0.1s ease-in-out; /* Added transform for press effect */
            cursor: pointer; /* Indicate clickable */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Subtle shadow for depth */
            -webkit-tap-highlight-color: transparent; /* Remove default tap highlight on mobile */
        }

        .light-mode .app-button {
            background-color: var(--light-button-bg);
            color: var(--light-text);
        }

        .dark-mode .app-button {
            background-color: var(--dark-button-bg);
            color: var(--dark-text);
        }

        .app-button:hover {
             background-color: var(--light-button-hover-bg); /* Hover state background */
             box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* More pronounced shadow on hover */
        }

        .dark-mode .app-button:hover {
             background-color: var(--dark-button-hover-bg); /* Hover state background in dark mode */
        }

        .app-button:active {
             transform: scale(0.95); /* Subtle press effect */
             box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); /* Reduced shadow on press */
        }

        /* Focus styles for accessibility */
        .app-button:focus-visible {
            outline: 2px solid var(--focus-ring-color-light);
            outline-offset: 2px;
        }

        .dark-mode .app-button:focus-visible {
            outline-color: var(--focus-ring-color-dark);
        }

         /* Style for the message box */
        .message-box {
            position: fixed;
            /* bottom will be set by JavaScript */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.85); /* Slightly darker background */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            font-size: 0.9rem; /* Slightly smaller font for message */
        }

        .message-box.show {
            opacity: 1;
        }

        /* Styles for the toggle switch (Material 3 inspired) */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 32px; /* Slightly adjusted height */
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #b0b0b0; /* Default grey for slider track */
            transition: .4s;
            border-radius: 32px; /* Fully rounded track */
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 24px; /* Slightly smaller handle */
            width: 24px; /* Slightly smaller handle */
            left: 4px;
            bottom: 4px;
            background-color: #ffffff; /* White handle */
            transition: .4s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); /* Shadow for the handle */
        }

        input:checked + .slider {
            background-color: var(--accent-color-light); /* Accent color when checked in light mode */
        }

        /* Dark mode slider checked color */
        .dark-mode input:checked + .slider {
             background-color: var(--accent-color-dark); /* Material 3 Light Teal in dark mode */
        }


        input:checked + .slider:before {
            transform: translateX(28px); /* Adjust translation distance */
        }

        input:focus-visible + .slider {
             box-shadow: 0 0 0 3px var(--focus-ring-color-light); /* Focus ring for toggle */
        }

        .dark-mode input:focus-visible + .slider {
             box-shadow: 0 0 0 3px var(--focus-ring-color-dark); /* Material 3 Light Teal focus in dark mode */
        }


        /* Styles for the floating controls container */
        .floating-controls {
            position: fixed; /* Keep fixed position relative to viewport */
            bottom: 1.5rem; /* Distance from the bottom */
            right: 1.5rem; /* Distance from the right */
            display: flex; /* Use flexbox to align items */
            align-items: center; /* Vertically center items */
            padding: 1rem 1.5rem; /* Padding inside the floating container */
            border-radius: 2rem; /* More rounded corners for the floating container */
            background-color: var(--floating-bg-light); /* Semi-transparent background */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* More pronounced shadow for floating effect */
            z-index: 990; /* Ensure it's above the textarea */
            transition: bottom 0.3s ease-out, background-color 0.3s ease; /* Smooth transition for position and mode change */
            gap: 1.5rem; /* Increased space between the toggle and the button group */
        }

        .dark-mode .floating-controls {
             background-color: var(--floating-bg-dark); /* Semi-transparent dark background */
        }

        /* Container for the right-aligned buttons */
        .right-aligned-buttons {
            display: flex;
            gap: 1rem; /* Add space between the buttons on the right */
        }

        /* Styles for the word count element */
        #wordCount {
            position: fixed; /* Fixed position relative to viewport */
            bottom: 1.5rem; /* Align with the bottom of floating controls */
            left: 1.5rem; /* Align with the left side, matching floating controls offset */
            padding: 0.5rem 1rem; /* Padding around the text */
            background-color: rgba(0, 0, 0, 0.6); /* Semi-transparent dark background */
            color: white; /* White text */
            border-radius: 1rem; /* Rounded corners */
            font-size: 0.9rem; /* Smaller font size */
            z-index: 990; /* Same z-index as floating controls */
            transition: bottom 0.3s ease-out; /* Smooth transition for position */
        }

    </style>
</head>
<body class="flex flex-col h-screen light-mode">
    <textarea id="noteTextarea" class="full-height-textarea"></textarea>

    <div class="floating-controls">
        <label class="toggle-switch">
            <input type="checkbox" id="modeToggleCheckbox">
            <span class="slider"></span>
        </label>

        <div class="right-aligned-buttons">
            <button id="clearButton" class="app-button">
                 <i class="fas fa-trash-alt"></i>
            </button>

            <button id="copyButton" class="app-button">
                <i class="fas fa-copy"></i>
            </button>
        </div>
    </div>

    <div id="wordCount">0</div>


    <div id="messageBox" class="message-box"></div>

    <script>
        const body = document.body;
        const noteTextarea = document.getElementById('noteTextarea');
        const modeToggleCheckbox = document.getElementById('modeToggleCheckbox'); // Renamed to reflect checkbox
        const clearButton = document.getElementById('clearButton');
        const copyButton = document.getElementById('copyButton');
        const messageBox = document.getElementById('messageBox');
        const floatingControls = document.querySelector('.floating-controls'); // Updated selector
        const wordCountElement = document.getElementById('wordCount'); // Get the word count element

        // Load mode preference from localStorage
        const savedMode = localStorage.getItem('mode');
        if (savedMode) {
            body.classList.remove('light-mode', 'dark-mode');
            body.classList.add(savedMode);
            // Set the checkbox state based on the loaded mode
            modeToggleCheckbox.checked = savedMode === 'dark-mode';
        } else {
            // Default to light mode if no preference is saved
            body.classList.add('light-mode');
            modeToggleCheckbox.checked = false; // Ensure checkbox is unchecked for light mode
        }

        // Load saved text from localStorage
        const savedText = localStorage.getItem('noteContent');
        if (savedText) {
            noteTextarea.value = savedText;
             updateWordCount(); // Update word count on load
        }

        // Function to show a message box
        function showMessage(message) {
            messageBox.textContent = message;
            messageBox.classList.add('show');
            setTimeout(() => {
                messageBox.classList.remove('show');
            }, 2000); // Hide after 2 seconds
        }

        // Function to update the word count
        function updateWordCount() {
            const text = noteTextarea.value.trim();
            const wordCount = text === '' ? 0 : text.split(/\s+/).filter(word => word !== '').length;
            wordCountElement.textContent = `${wordCount}`;
        }


        // Event listener for mode toggle checkbox change
        modeToggleCheckbox.addEventListener('change', () => {
            if (modeToggleCheckbox.checked) {
                body.classList.remove('light-mode');
                body.classList.add('dark-mode');
                localStorage.setItem('mode', 'dark-mode');
            } else {
                body.classList.remove('dark-mode');
                body.classList.add('light-mode');
                localStorage.setItem('mode', 'light-mode');
            }
        });

        // Event listener for clear button
        clearButton.addEventListener('click', () => {
            noteTextarea.value = '';
            localStorage.removeItem('noteContent'); // Clear saved text from localStorage
            updateWordCount(); // Update word count after clearing
        });

        // Event listener for copy button
        copyButton.addEventListener('click', async () => {
            try {
                await navigator.clipboard.writeText(noteTextarea.value);
                showMessage('Content copied to clipboard!');
            } catch (err) {
                console.error('Failed to copy: ', err);
                showMessage('Failed to copy content.');
            }
        });

        // Save text to localStorage and update word count whenever the user types
        noteTextarea.addEventListener('input', () => {
            localStorage.setItem('noteContent', noteTextarea.value);
            updateWordCount(); // Update word count on input
        });

        // Register the service worker
        if ('serviceWorker' in navigator) {
          window.addEventListener('load', () => {
            navigator.serviceWorker.register('/sw.js')
              .then(registration => {
                console.log('Service Worker registered: ', registration);
              })
              .catch(error => {
                console.log('Service Worker registration failed: ', error);
              });
          });
        }

        // Function to adjust layout based on visual viewport (including keyboard)
        function adjustLayoutForKeyboard() {
            if (window.visualViewport) {
                const viewportHeight = window.visualViewport.height;
                const layoutViewportHeight = window.innerHeight;

                // Calculate the height of the area below the visual viewport (likely the keyboard)
                const keyboardAreaHeight = layoutViewportHeight - viewportHeight;

                // Calculate the desired bottom position for the floating elements
                // This is the height of the keyboard area plus the initial desired offset from the bottom of the visual viewport
                const initialBottomOffset = 1.5 * 16; // 1.5rem converted to pixels
                const newBottomPosition = keyboardAreaHeight + initialBottomOffset;

                // Adjust the bottom position of the floating controls and word count
                floatingControls.style.bottom = `${newBottomPosition}px`;
                wordCountElement.style.bottom = `${newBottomPosition}px`; // Align word count with controls

                // Calculate the required padding-bottom for the textarea.
                // This padding should be enough to ensure the last line of text is visible above the floating elements when the keyboard is up.
                // It should be at least the height of the floating controls + their initial bottom offset + a buffer.
                const floatingControlsHeight = floatingControls.offsetHeight;
                const requiredPaddingBottom = floatingControlsHeight + initialBottomOffset + 16; // Add a little extra padding

                // Set the padding-bottom of the textarea
                noteTextarea.style.paddingBottom = `${requiredPaddingBottom}px`;

                 // Also adjust message box position relative to the new floating controls position
                 messageBox.style.bottom = `${newBottomPosition + floatingControlsHeight + 16}px`; // Position above the floating controls
            } else {
                 // Fallback for browsers that don't support visualViewport
                 // Keep the original floating elements position
                 floatingControls.style.bottom = '1.5rem';
                 wordCountElement.style.bottom = '1.5rem';
                 // Revert textarea padding-bottom to a default if visualViewport is not supported
                 noteTextarea.style.paddingBottom = '8rem'; // Revert to the fixed value
                 messageBox.style.bottom = '5rem'; // This might need adjustment based on actual footer height in fallback
            }
        }

        // Adjust layout on initial load and on visual viewport resize (keyboard appearance/disappearance)
        window.addEventListener('load', adjustLayoutForKeyboard);
        if (window.visualViewport) {
             window.visualViewport.addEventListener('resize', adjustLayoutForKeyboard);
        } else {
            // Add a regular resize listener as a fallback if visualViewport is not supported
            window.addEventListener('resize', adjustLayoutForKeyboard);
        }

        // Initial word count update on load
        updateWordCount();


    </script>
</body>
</html>
